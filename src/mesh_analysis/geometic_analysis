use std::fs::File;                          
use std::io::{self};    // For input/output operations 
use std::f64;            // Import f64 constants like INFINITY

use crate::database::*;                // Import mesh data structures and error types from database module



#[derive(Debug, Clone, Copy, PartialEq)]
enum Topology {
    Line,
    Triangle,
    Quad,
    Tetra,
    Pyramid,
    Wedge,
    Hexahedron,
}

#[derive(Debug, Clone, Copy, PartialEq)]
enum Family { //serendipity and lagrange elements are the same for the first order elements
    Lagrange,
    Serendipity,
    Mixed,
}

#[derive(Debug, Clone, Copy)]
struct ElementSignature {
    topology: Topology,
    family: Family,
    order: usize,
}

#[derive(Debug, Clone)]
struct ShapeFunction {
    values: Vec<f64>,
    derivatives: Vec<Vec<f64>>, // derivatives[node][dimension]
}

#[derive(Debug, Clone)]
pub struct Jacobian {
    pub matrix: Vec<Vec<f64>>, // Jacobian matrix J[i][j] = dx_i/dxi_j
    pub determinant: f64,
}

#[derive(Debug, Clone)]
pub struct ElementQuality {
    pub det_jacobian: f64,      // det J
    // pub skewness: f64,       // angle distortion error
    // pub aspect_ratio: f64,  // length scaling error

    // more quality metrics can be added here
}


// Structure to define reference element in isoparametric coordinates
#[derive(Debug, Clone)]
pub struct ReferenceElement {
    pub element_type: ElementType,          // Type of element (quad, triangle, etc.)
    pub reference_coords: Vec<Vec<f64>>,    // Reference coordinates for each node in natural space
    pub num_nodes: usize,                   // Number of nodes in reference element
}

// Structure to hold the complete mesh quality analysis results
#[derive(Debug, Clone)]
pub struct MeshQualityReport {
    pub total_elements: usize,                    // Total number of elements that were successfully analyzed
    pub element_qualities: Vec<ElementQuality>,   // Quality metrics for each individual element
    // pub statistics: QualityStatistics,           // Overall statistical summary of mesh quality
}

/* 
// Structure to hold statistical summary of mesh quality metrics
#[derive(Debug, Clone)]
pub struct QualityStatistics {
    pub min_jacobian: f64,              // Minimum Jacobian determinant in the mesh
    pub max_jacobian: f64,              // Maximum Jacobian determinant in the mesh
    pub avg_jacobian: f64,              // Average Jacobian determinant across all elements
    pub negative_jacobian_count: usize, // Number of elements with negative Jacobian (invalid elements)
    pub min_aspect_ratio: f64,          // Best (lowest) aspect ratio in the mesh
    pub max_aspect_ratio: f64,          // Worst (highest) aspect ratio in the mesh
    pub avg_aspect_ratio: f64,          // Average aspect ratio across all elements
    pub avg_skewness: f64,              // Average skewness across all elements
    pub max_skewness: f64,              // Worst (highest) skewness in the mesh
} */

pub struct GeometricAnalysis;  // Defines a structure to represent the geometric analysis for the mesh elements

impl GeometricAnalysis {
    /// Create reference element definitions in isoparametric coordinates
    /// These define the "perfect" element shapes in natural coordinate space
    pub fn get_reference_element(element_type: &ElementType) -> Result<ReferenceElement, ElementError> {
        match element_type {
            ElementType::Line => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![-1.0],    // Node 0 at xi = -1
                    vec![1.0],     // Node 1 at xi = 1
                ],
                num_nodes: 2,
            }), 
            
            ElementType::QuadraticEdge => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![-1.0],    // Node 0 at xi = -1
                    vec![1.0],     // Node 1 at xi = 1
                    vec![0.0],     // Node 2 at xi = 0 (middle)
                ],
                num_nodes: 3,
            }),
            
            ElementType::Triangle => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![1.0, 0.0],    // Node 0 at (1,0)
                    vec![0.0, 1.0],    // Node 1 at (0,1)
                    vec![0.0, 0.0],    // Node 2 at origin
                ],
                num_nodes: 3,
            }),
            
            ElementType::QuadraticTriangle => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![1.0, 0.0],    // Node 0 at (1,0)
                    vec![0.0, 1.0],    // Node 1 at (0,1)
                    vec![0.0, 0.0],    // Node 2 at origin
                    vec![0.5, 0.5],    // Node 3: mid-edge between 0-1
                    vec![0.0, 0.5],    // Node 4: mid-edge between 1-2
                    vec![0.5, 0.0],    // Node 5: mid-edge between 2-0
                ],
                num_nodes: 6,
            }),
            
            ElementType::Quad => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![-1.0, -1.0],    // Node 0: bottom-left corner
                    vec![1.0, -1.0],     // Node 1: bottom-right corner
                    vec![1.0, 1.0],      // Node 2: top-right corner
                    vec![-1.0, 1.0],     // Node 3: top-left corner
                ],
                num_nodes: 4,
            }),
            
            ElementType::QuadraticQuad => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![-1.0, -1.0],    // Node 0: corner bottom-left
                    vec![1.0, -1.0],     // Node 1: corner bottom-right
                    vec![1.0, 1.0],      // Node 2: corner top-right
                    vec![-1.0, 1.0],     // Node 3: corner top-left
                    vec![0.0, -1.0],     // Node 4: mid-edge bottom
                    vec![1.0, 0.0],      // Node 5: mid-edge right
                    vec![0.0, 1.0],      // Node 6: mid-edge top
                    vec![-1.0, 0.0],     // Node 7: mid-edge left
                ],
                num_nodes: 8,
            }),
            
            ElementType::BiquadraticQuad => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![-1.0, -1.0],    // Node 0: corner bottom-left
                    vec![1.0, -1.0],     // Node 1: corner bottom-right
                    vec![1.0, 1.0],      // Node 2: corner top-right
                    vec![-1.0, 1.0],     // Node 3: corner top-left
                    vec![0.0, -1.0],     // Node 4: mid-edge bottom
                    vec![1.0, 0.0],      // Node 5: mid-edge right
                    vec![0.0, 1.0],      // Node 6: mid-edge top
                    vec![-1.0, 0.0],     // Node 7: mid-edge left
                    vec![0.0, 0.0],      // Node 8: center node
                ],
                num_nodes: 9,
            }),
            
            ElementType::Tetra => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![1.0, 0.0, 0.0],     // Node 0: on xi-axis
                    vec![0.0, 1.0, 0.0],     // Node 1: on eta-axis
                    vec![0.0, 0.0, 1.0],     // Node 2: on psi-axis
                    vec![0.0, 0.0, 0.0],     // Node 3: at origin
                ],
                num_nodes: 4,
            }),
            
            ElementType::QuadraticTetra => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![1.0, 0.0, 0.0],     // Node 0: on xi-axis
                    vec![0.0, 1.0, 0.0],     // Node 1: on eta-axis
                    vec![0.0, 0.0, 1.0],     // Node 2: on psi-axis
                    vec![0.0, 0.0, 0.0],     // Node 3: at origin
                    vec![0.5, 0.5, 0.0],     // Node 4: mid-edge 0-1
                    vec![0.0, 0.5, 0.5],     // Node 5: mid-edge 1-2
                    vec![0.5, 0.0, 0.5],     // Node 6: mid-edge 0-2
                    vec![0.5, 0.0, 0.0],     // Node 7: mid-edge 0-3
                    vec![0.0, 0.5, 0.0],     // Node 8: mid-edge 1-3
                    vec![0.0, 0.0, 0.5],     // Node 9: mid-edge 2-3
                ],
                num_nodes: 10,
            }),

            ElementType::Pyramid => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![-1.0, -1.0, -1.0],    // Node 0: top-left corner at base
                    vec![-1.0, -1.0, 1.0],     // Node 1: bottom-left corner at base
                    vec![1.0, -1.0, 1.0],      // Node 2: bottom-right corner at base
                    vec![1.0, -1.0, -1.0],     // Node 3: top-right corner at base
                    vec![0.0, 1.0, 0.0],       // Node 4: at apex
                ],
                num_nodes: 5,
            }),

            ElementType::Wedge => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![0.0, -1.0, 0.0],       // Node 0: bottom face, xxx
                    vec![0.0, -1.0, 1.0],       // Node 1: bottom face, xxx
                    vec![1.0, -1.0, 0.0],       // Node 2: bottom face, xxx
                    vec![0.0, 1.0, 0.0],        // Node 3: top face, xxx
                    vec![0.0, 1.0, 1.0],        // Node 4: top face, xxx
                    vec![1.0, 1.0, 0.0],        // Node 5: top face, xxx
                ],
                num_nodes: 6,
            }),

            ElementType::QuadraticWedge => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![0.0, -1.0, 0.0],       // Node 0: bottom face, xxx
                    vec![0.0, -1.0, 1.0],       // Node 1: bottom face, xxx
                    vec![1.0, -1.0, 0.0],       // Node 2: bottom face, xxx
                    vec![0.0, 1.0, 0.0],        // Node 3: top face, xxx
                    vec![0.0, 1.0, 1.0],        // Node 4: top face, xxx
                    vec![1.0, 1.0, 0.0],        // Node 5: top face, xxx
                    // mid-edge nodes
                    vec![0.0, -1.0, 0.5],       // Node 6: bottom face, mid-edge 0-1
                    vec![0.5, -1.0, 0.5],       // Node 7: bottom face, mid-edge 1-2
                    vec![0.5, -1.0, 0.0],       // Node 8: bottom face, mid-edge 0-2
                    vec![0.0, 1.0, 0.5],        // Node 9: top face, mid-edge 3-4
                    vec![0.5, 1.0, 0.5],        // Node 10: top face, mid-edge 4-5
                    vec![0.5, 1.0, 0.0],        // Node 11: top face, mid-edge 3-5
                    vec![0.0, 0.0, 0.0],        // Node 12: mid-edge 0-3
                    vec![0.0, 0.0, 1.0],        // Node 13: mid-edge 1-4
                    vec![1.0, 0.0, 0.0],        // Node 14: mid-edge 2-5
                ],
                num_nodes: 15,
            }),

            ElementType::BiquadraticQuadraticWedge => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![0.0, -1.0, 0.0],       // Node 0: bottom face, xxx
                    vec![0.0, -1.0, 1.0],       // Node 1: bottom face, xxx
                    vec![1.0, -1.0, 0.0],       // Node 2: bottom face, xxx
                    vec![0.0, 1.0, 0.0],        // Node 3: top face, xxx
                    vec![0.0, 1.0, 1.0],        // Node 4: top face, xxx
                    vec![1.0, 1.0, 0.0],        // Node 5: top face, xxx
                    // mid-edge nodes
                    vec![0.0, -1.0, 0.5],       // Node 6: bottom face, mid-edge 0-1
                    vec![0.5, -1.0, 0.5],       // Node 7: bottom face, mid-edge 1-2
                    vec![0.5, -1.0, 0.0],       // Node 8: bottom face, mid-edge 0-2
                    vec![0.0, 1.0, 0.5],        // Node 9: top face, mid-edge 3-4
                    vec![0.5, 1.0, 0.5],        // Node 10: top face, mid-edge 4-5
                    vec![0.5, 1.0, 0.0],        // Node 11: top face, mid-edge 3-5
                    vec![0.0, 0.0, 0.0],        // Node 12: mid-edge 0-3
                    vec![0.0, 0.0, 1.0],        // Node 13: mid-edge 1-4
                    vec![1.0, 0.0, 0.0],        // Node 14: mid-edge 2-5
                    // mid-face nodes
                    vec![0.0, 0.0, 0.5],        // Node 15: mid-edge 12-13
                    vec![0.5, 0.0, 0.5],        // Node 16: mid-edge 13-14
                    vec![0.5, 0.0, 0.0],        // Node 17: mid-edge 12-14
                ],
                num_nodes: 18,
            }),
            
            ElementType::Hexahedron => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    vec![-1.0, -1.0, -1.0],  // Node 0: bottom face, top-left
                    vec![-1.0, -1.0, 1.0],   // Node 1: bottom face, bottom-left
                    vec![1.0, -1.0, 1.0],    // Node 2: bottom face, bottom-right
                    vec![1.0, -1.0, -1.0],   // Node 3: bottom face, top-right
                    vec![-1.0, 1.0, -1.0],   // Node 4: top face, top-left
                    vec![-1.0, 1.0, 1.0],    // Node 5: top face, bottom-left
                    vec![1.0, 1.0, 1.0],     // Node 6: top face, bottom-right
                    vec![1.0, 1.0, -1.0],    // Node 7: top face, top-right
                ],
                num_nodes: 8,
            }),
            
            ElementType::QuadraticHexahedron => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    // corner nodes
                    vec![-1.0, -1.0, -1.0],  // Node 0: bottom face, top-left
                    vec![-1.0, -1.0, 1.0],   // Node 1: bottom face, bottom-left
                    vec![1.0, -1.0, 1.0],    // Node 2: bottom face, bottom-right
                    vec![1.0, -1.0, -1.0],   // Node 3: bottom face, top-right
                    vec![-1.0, 1.0, -1.0],   // Node 4: top face, top-left
                    vec![-1.0, 1.0, 1.0],    // Node 5: top face, bottom-left
                    vec![1.0, 1.0, 1.0],     // Node 6: top face, bottom-right
                    vec![1.0, 1.0, -1.0],    // Node 7: top face, top-right
                    // mid-edge nodes
                    vec![-1.0, -1.0, 0.0],   // Node 8: bottom face, left edge
                    vec![0.0, -1.0, 1.0],    // Node 9: bottom face, front edge
                    vec![1.0, -1.0, 0.0],    // Node 10: bottom face, right edge
                    vec![0.0, -1.0, -1.0],   // Node 11: bottom face, back edge
                    vec![-1.0, -1.0, 0.0],   // Node 12: top face, left edge
                    vec![0.0, 1.0, 1.0],     // Node 13: top face, front edge
                    vec![1.0, 1.0, 0.0],     // Node 14: top face, right edge
                    vec![0.0, 1.0, -1.0],    // Node 15: top face, back edge
                    vec![-1.0, 0.0, -1.0],   // Node 16: left face, left edge
                    vec![-1.0, 0.0, 1.0],    // Node 17: left face, right edge
                    vec![1.0, 0.0, 1.0],     // Node 18: right face, left edge
                    vec![1.0, 0.0, -1.0],    // Node 19: right face, right edge
                ],
                num_nodes: 20,
            }),

            ElementType::BiquadraticQuadraticHexahedron => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    // corner nodes
                    vec![-1.0, -1.0, -1.0],  // Node 0: bottom face, top-left
                    vec![-1.0, -1.0, 1.0],   // Node 1: bottom face, bottom-left
                    vec![1.0, -1.0, 1.0],    // Node 2: bottom face, bottom-right
                    vec![1.0, -1.0, -1.0],   // Node 3: bottom face, top-right
                    vec![-1.0, 1.0, -1.0],   // Node 4: top face, top-left
                    vec![-1.0, 1.0, 1.0],    // Node 5: top face, bottom-left
                    vec![1.0, 1.0, 1.0],     // Node 6: top face, bottom-right
                    vec![1.0, 1.0, -1.0],    // Node 7: top face, top-right
                    // mid-edge nodes
                    vec![-1.0, -1.0, 0.0],   // Node 8: bottom face, left edge
                    vec![0.0, -1.0, 1.0],    // Node 9: bottom face, front edge
                    vec![1.0, -1.0, 0.0],    // Node 10: bottom face, right edge
                    vec![0.0, -1.0, -1.0],   // Node 11: bottom face, back edge
                    vec![-1.0, -1.0, 0.0],   // Node 12: top face, left edge
                    vec![0.0, 1.0, 1.0],     // Node 13: top face, front edge
                    vec![1.0, 1.0, 0.0],     // Node 14: top face, right edge
                    vec![0.0, 1.0, -1.0],    // Node 15: top face, back edge
                    vec![-1.0, 0.0, -1.0],   // Node 16: left face, left edge
                    vec![-1.0, 0.0, 1.0],    // Node 17: left face, right edge
                    vec![1.0, 0.0, 1.0],     // Node 18: right face, left edge
                    vec![1.0, 0.0, -1.0],    // Node 19: right face, right edge
                    // mid-face nodes
                    vec![0.0, 0.0, -1.0],    // Node 20: back face, mid
                    vec![0.0, 0.0, 1.0],     // Node 21: front face, mid
                    vec![-1.0, 0.0, 0.0],    // Node 22: left face, mid
                    vec![1.0, 0.0, 0.0],     // Node 23: right face, mid
                ],
                num_nodes: 24,
            }),

            ElementType::TriQuadraticHexahedron => Ok(ReferenceElement {
                element_type: element_type.clone(),
                reference_coords: vec![
                    // corner nodes
                    vec![-1.0, -1.0, -1.0],  // Node 0: bottom face, top-left
                    vec![-1.0, -1.0, 1.0],   // Node 1: bottom face, bottom-left
                    vec![1.0, -1.0, 1.0],    // Node 2: bottom face, bottom-right
                    vec![1.0, -1.0, -1.0],   // Node 3: bottom face, top-right
                    vec![-1.0, 1.0, -1.0],   // Node 4: top face, top-left
                    vec![-1.0, 1.0, 1.0],    // Node 5: top face, bottom-left
                    vec![1.0, 1.0, 1.0],     // Node 6: top face, bottom-right
                    vec![1.0, 1.0, -1.0],    // Node 7: top face, top-right
                    // mid-edge nodes
                    vec![-1.0, -1.0, 0.0],   // Node 8: bottom face, left edge
                    vec![0.0, -1.0, 1.0],    // Node 9: bottom face, front edge
                    vec![1.0, -1.0, 0.0],    // Node 10: bottom face, right edge
                    vec![0.0, -1.0, -1.0],   // Node 11: bottom face, back edge
                    vec![-1.0, -1.0, 0.0],   // Node 12: top face, left edge
                    vec![0.0, 1.0, 1.0],     // Node 13: top face, front edge
                    vec![1.0, 1.0, 0.0],     // Node 14: top face, right edge
                    vec![0.0, 1.0, -1.0],    // Node 15: top face, back edge
                    vec![-1.0, 0.0, -1.0],   // Node 16: left face, left edge
                    vec![-1.0, 0.0, 1.0],    // Node 17: left face, right edge
                    vec![1.0, 0.0, 1.0],     // Node 18: right face, left edge
                    vec![1.0, 0.0, -1.0],    // Node 19: right face, right edge
                    // mid-face nodes
                    vec![0.0, 0.0, -1.0],    // Node 20: back face, mid
                    vec![0.0, 0.0, 1.0],     // Node 21: front face, mid
                    vec![-1.0, 0.0, 0.0],    // Node 22: left face, mid
                    vec![1.0, 0.0, 0.0],     // Node 23: right face, mid
                    vec![0.0, -1.0, 0.0],    // Node 24: bottom face, mid
                    vec![0.0, 1.0, 0.0],     // Node 25: top face, mid
                    // center node
                    vec![0.0, 0.0, 0.0],     // Node 26: center 
                ],
                num_nodes: 27,
            }),

            // Add other element types as needed...
            _ => Err(ElementError::InvalidElement(format!("Reference element not implemented for {:?}", element_type))),
        }
    }

    /// Main method to analyze quality of all elements in the mesh using reference elements
    pub fn analyse_mesh_quality(mesh_data: &MeshData) -> Result<MeshQualityReport, ElementError> {
        let mut element_qualities = Vec::new();  // Vector to store quality metrics for each element
        let mut processed_elements = 0;         // Counter for successfully processed elements
        
        // Process elements by type groups using the element_type_info from parsed data
        for type_info in &mesh_data.element_type_info {
            // Skip vertex elements as they don't have meaningful quality metrics
            if matches!(type_info.element_type, ElementType::Vertex) {
                continue;  // Move to next element type
            }
            
            // Create reference element for this element type
            let reference_element = Self::get_reference_element(&type_info.element_type)?;
            
            // Calculate the range of elements for this type
            let start_idx = type_info.start_index;                    // First element index of this type
            let end_idx = start_idx + type_info.num_elements;         // One past last element index of this type
            
            // Process each element of this specific type
            for element_idx in start_idx..end_idx {
                // Check if element index is valid (within bounds of elements vector)
                if element_idx < mesh_data.elements.len() {
                    let element = &mesh_data.elements[element_idx];  // Get reference to current element
                    
                    // Attempt to calculate quality metrics for this element
                    match Self::calculate_element_quality_with_reference(element, &reference_element, &mesh_data.nodes) {
                        Ok(quality) => {
                            // Success: store the quality metrics and increment counter
                            element_qualities.push(quality);
                            processed_elements += 1;
                        },
                        Err(e) => {
                            // Failure: print warning but continue processing other elements
                            println!("Warning: Failed to analyze element {}: {:?}", element.id, e);
                        }
                    }
                }
            }
        }
        
        // Check if we successfully analyzed any elements
        if element_qualities.is_empty() {
            return Err(ElementError::GeometryError("No elements could be analyzed".to_string()));
        }
        
        // Calculate overall statistics from individual element qualities
        let statistics = Self::calculate_statistics(&element_qualities);
        
        // Return the complete quality report
        Ok(MeshQualityReport {
            total_elements: processed_elements,
            element_qualities,
            statistics,
        })
    }

    /// Calculate element quality using full reference element comparison
    /// This computes Jacobian at element from nodes and comprehensive quality metrics
    fn calculate_element_quality_with_reference(
        element: &Element,                    // The element to analyze
        reference_element: &ReferenceElement, // The reference element definition
        nodes: &[Node]                       // All nodes in the mesh
    ) -> Result<ElementQuality, ElementError> {
        // Get the actual node coordinates for this element
        let element_nodes = Self::get_element_nodes(element, nodes)?;
        
        // Verify element has correct number of nodes
        if element_nodes.len() != reference_element.num_nodes {
            return Err(ElementError::InvalidElement(format!(
                "Element has {} nodes, but reference element expects {}", 
                element_nodes.len(), 
                reference_element.num_nodes
            )));
        }
        
        // Calculate Jacobians at multiple reference points for more comprehensive analysis
        let jacobian_results = Self::calculate_jacobians_at_reference_points(
            element, 
            &element_nodes, 
            reference_element, 
            &reference_element.element_type
        )?;
        
        // Calculate Jacobian determinant as quality metrics
        let det_jacobian = get_jacobian.determinant();

        // Calculate geometric quality metrics
        let skewness = Self::calculate_skewness_with_reference(&element_nodes, reference_element)?;
        let aspect_ratio = Self::calculate_aspect_ratio_with_reference(&element_nodes, reference_element)?;
        
        // Return all quality metrics
        Ok(ElementQuality {
            det_jacobian,
            skewness,
            aspect_ratio,
        })
    }

    /// Calculate Jacobians at element from nodes for comprehensive analysis  
    fn calculate_jacobians_at_reference_points(
        element: &Element,
        element_nodes: &[Node],
        reference_element: &ReferenceElement,
        element_type: &ElementType
    ) -> Result<Vec<Jacobian>, ElementError> {
        let mut jacobians = Vec::new();  // Store Jacobian matrices at different points
        
        
    }

    /// Convert our Node vector to the format expected by get_jacobian method
    fn nodes_to_mesh_nodes(element_nodes: &[Node]) -> Vec<Node> {
        element_nodes.to_vec()  // Simple conversion - already in correct format
    }

    /// Calculate skewness using reference element comparison
    /// Measures deviation from ideal reference element shape
    fn calculate_skewness_with_reference(element_nodes: &[Node], reference_element: &ReferenceElement) -> Result<f64, ElementError> {
        
    }

    /// Calculate aspect ratio using reference element comparison
    fn calculate_aspect_ratio_with_reference(element_nodes: &[Node], reference_element: &ReferenceElement) -> Result<f64, ElementError> {
        
    }

    /// Get the nodes associated with an element
    fn get_element_nodes(element: &Element, nodes: &[Node]) -> Result<Vec<Node>, ElementError> {
        let mut element_nodes = Vec::new();  // Vector to store the found nodes
        
        // Look up each node ID in the element's node list
        for &node_id in &element.nodes {
            // Search for node with matching ID in the mesh's node list
            if let Some(node) = nodes.iter().find(|n| n.id == node_id) {
                element_nodes.push(node.clone());  // Found: add node to our list
            } else {
                // Node ID not found in mesh - this is an error
                return Err(ElementError::InvalidElement(format!("Node {} not found for element {}", node_id, element.id)));
            }
        }
        
        // Verify we found at least some nodes
        if element_nodes.is_empty() {
            return Err(ElementError::InvalidElement(format!("No valid nodes found for element {}", element.id)));
        }
        
        Ok(element_nodes)  // Return the collected nodes
    }

    /// Calculate statistics for all element qualities
    fn calculate_statistics(qualities: &[ElementQuality]) -> QualityStatistics {

    }
}

impl ElementType {
    fn from_element_type_to_signature(element_type: ElementType) -> Result<ElementSignature, ParseError> {
        match element_type {
            ElementType::Line => Ok(ElementSignature { 
                topology: Topology::Line,
                family: Family::Lagrange, 
                order: 1,
            }),
            ElementType::QuadraticEdge => Ok(ElementSignature {
                topology: Topology::Line,
                family: Family::Lagrange,
                order: 2,
            }),
            ElementType::Triangle => Ok(ElementSignature {
                topology: Topology::Triangle,
                family: Family::Lagrange,
                order: 1,
            }),
            ElementType::QuadraticTriangle => Ok(ElementSignature {
                topology: Topology::Triangle,
                family: Family::Lagrange,
                order: 2,
            }),
            ElementType::Quad => Ok(ElementSignature {
                topology: Topology::Quad,
                family: Family::Lagrange,
                order: 1,
            }),
            ElementType::QuadraticQuad => Ok(ElementSignature {
                topology: Topology::Quad,
                family: Family::Serendipity,
                order: 2,
            }),
            ElementType::BiquadraticQuad => Ok(ElementSignature {
                topology: Topology::Quad,
                family: Family::Lagrange,
                order: 2,
            }),
            ElementType::Tetra => Ok(ElementSignature {
                topology: Topology::Tetra,
                family: Family::Lagrange,
                order: 1,
            }),
            ElementType::QuadraticTetra => Ok(ElementSignature {
                topology: Topology::Tetra,
                family: Family::Lagrange,
                order: 2,
            }),
            ElementType::Pyramid => Ok(ElementSignature {
                topology: Topology::Pyramid,
                family: Family::Lagrange,
                order: 1,
            }),
            ElementType::QuadraticPyramid => Ok(ElementSignature {
                topology: Topology::Pyramid,
                family: Family::Lagrange,
                order: 2,
            }),
            ElementType::Wedge => Ok(ElementSignature {
                topology: Topology::Wedge,
                family: Family::Lagrange,
                order: 1,
            }),
            ElementType::QuadraticWedge => Ok(ElementSignature {
                topology: Topology::Wedge,
                family: Family::Lagrange,
                order: 2,
            }),
            ElementType::BiquadraticQuadraticWedge => Ok(ElementSignature {
                topology: Topology::Wedge,
                family: Family::Mixed,
                order: 2,
            }),
            ElementType::Hexahedron => Ok(ElementSignature {
                topology: Topology::Hexahedron,
                family: Family::Lagrange,
                order: 1,
            }),
            ElementType::QuadraticHexahedron => Ok(ElementSignature {
                topology: Topology::Hexahedron,
                family: Family::Serendipity,
                order: 2,
            }),
            ElementType::BiquadraticQuadraticHexahedron => Ok(ElementSignature {
                topology: Topology::Hexahedron,
                family: Family::Mixed,
                order: 2,
            }),
            ElementType::TriquadraticHexahedron => Ok(ElementSignature {
                topology: Topology::Hexahedron,
                family: Family::Lagrange,
                order: 2,
            }),
            ElementType::Vertex => Err(ParseError::ElementError("Vertex element - skipping Jacobian calculation".to_string())),
        }
    }

    /// Get shape functions for any element type at given natural coordinates
    pub fn get_shape_functions(&self, xi: &[f64]) -> Result<ShapeFunction, ParseError> {
        match self {
            ElementType::Line => get_line_shape_functions(xi),
            ElementType::QuadraticEdge => get_quadratic_edge_shape_functions(xi),
            ElementType::Triangle => get_triangle_shape_functions(xi),
            ElementType::QuadraticTriangle => get_quadratic_triangle_shape_functions(xi),
            ElementType::Quad => get_quad_shape_functions(xi),
            ElementType::QuadraticQuad => get_quadratic_quad_shape_functions(xi),
            ElementType::BiquadraticQuad => get_biquadratic_quad_shape_functions(xi),
            ElementType::Tetra => get_tetra_shape_functions(xi),
            ElementType::QuadraticTetra => get_quadratic_tetra_shape_functions(xi),
            ElementType::Pyramid => get_pyramid_shape_functions(xi),
            ElementType::QuadraticPyramid => get_quadratic_pyramid_shape_functions(xi),
            ElementType::Wedge => get_wedge_shape_functions(xi),
            ElementType::QuadraticWedge => get_quadratic_wedge_shape_functions(xi),
            ElementType::BiquadraticQuadraticWedge => get_biquadratic_quadratic_wedge_shape_functions(xi),
            ElementType::Hexahedron => get_hexahedron_shape_functions(xi),
            ElementType::QuadraticHexahedron => get_quadratic_hexahedron_shape_functions(xi),
            ElementType::BiquadraticQuadraticHexahedron => get_biquadratic_quadratic_hexahedron_shape_functions(xi),
            ElementType::TriquadraticHexahedron => get_triquadratic_hexahedron_shape_functions(xi),
            ElementType::Vertex => Err(ParseError::ElementError("Vertex elements have no shape functions".to_string())),
        }
    }

        /// Compute Jacobian matrix for an element at given natural coordinates
    pub fn get_jacobian(
        &self,
        element: &Element,
        nodes: &[Node],
        xi: &[f64], // Natural coordinates
    ) -> Result<Jacobian, ParseError> {
        // Handle vertex elements gracefully
        if matches!(self, ElementType::Vertex) {
            return Err(ParseError::ElementError("Vertex element - skipping Jacobian calculation".to_string()));
        }

        // Get shape functions for this element type
        let shape_fn = self.get_shape_functions(xi)?;
        
        // Determine spatial dimension from nodes
        if nodes.is_empty() {
            return Err(ParseError::FormatError("No nodes provided for Jacobian calculation".to_string()));
        }
        
        let spatial_dim = nodes[0].coordinates.len();
        let natural_dim = xi.len();
        
        // Initialize Jacobian matrix
        let mut jacobian_matrix = vec![vec![0.0; natural_dim]; spatial_dim];
        
        // Compute Jacobian: J[i][j] = sum(N_k,j * x_k_i)
        for i in 0..spatial_dim {
            for j in 0..natural_dim {
                for (node_idx, &global_node_id) in element.nodes.iter().enumerate() {
                    // Find the node in the nodes array
                    if let Some(node) = nodes.iter().find(|n| n.id == global_node_id) {
                        if node_idx < shape_fn.derivatives.len() && j < shape_fn.derivatives[node_idx].len() {
                            jacobian_matrix[i][j] += shape_fn.derivatives[node_idx][j] * node.coordinates[i];
                        }
                    }
                }
            }
        }
        
        // Calculate determinant
        let det = Self::calculate_determinant(&jacobian_matrix)?;
        
        Ok(Jacobian {
            matrix: jacobian_matrix,
            determinant: det,
        })
    }

    /// Calculate determinant of Jacobian matrix with proper handling of dimension mismatch
    /// Returns signed determinant for square matrices, signed magnitude for non-square matrices
    fn calculate_determinant(matrix: &[Vec<f64>]) -> Result<f64, ParseError> {
        let spatial_dim = matrix.len();  // Number of rows = spatial dimensions of the mesh
        if spatial_dim == 0 {
            return Err(ParseError::FormatError("Cannot calculate determinant of empty matrix".to_string()));
        }
        
        // Verify matrix is rectangular (all rows have same length)
        for row in matrix {
            if row.len() != matrix[0].len() {
                return Err(ParseError::FormatError("Matrix must be rectangular for determinant calculation".to_string()));
            }
        }
        
        let natural_dim = matrix[0].len();  // Number of columns = natural/parametric dimensions of element
        
        match (spatial_dim, natural_dim) {
            // Case 1: Square matrices - element dimension matches mesh dimension
            // Use standard determinant calculation det(J)
            (1, 1) => {
                // 1D element in 1D mesh: det(J) = J[0,0] = dx/dxi
                Ok(matrix[0][0])
            },
            
            (2, 2) => {
                // 2D element in 2D mesh: det(J) = J[0,0]*J[1,1] - J[0,1]*J[1,0]
                // This gives the area scaling factor (can be negative if element is inverted)
                Ok(matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0])
            },
            
            (3, 3) => {
                // 3D element in 3D mesh: standard 3x3 determinant
                // This gives the volume scaling factor (can be negative if element is inverted)
                Ok(matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
                - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
                + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]))
            }
            
            // Case 2: Non-square matrices - element dimension != mesh dimension
            // Use signed sqrt(det(G)) where G = J^T * J for Jacobian magnitude
            (spatial, natural) if spatial != natural => {
                // Step 1: Calculate G = J^T * J (Gram matrix)
                // G[i,j] = sum_k(J[k,i] * J[k,j]) for all spatial dimensions k
                let mut g = vec![vec![0.0; natural]; natural];
                
                for i in 0..natural {           // Loop over natural coordinate i
                    for j in 0..natural {       // Loop over natural coordinate j
                        for k in 0..spatial {   // Sum over all spatial dimensions k
                            // G[i,j] += J[k,i] * J[k,j]
                            g[i][j] += matrix[k][i] * matrix[k][j];
                        }
                    }
                }
                
                // Step 2: Calculate determinant of G
                let det_g = match natural {
                    1 => {
                        // 1D element: G is 1x1, det(G) = G[0,0] = ||dx/dxi||²
                        g[0][0]
                    },
                    
                    2 => {
                        // 2D element: G is 2x2, standard 2x2 determinant
                        g[0][0] * g[1][1] - g[0][1] * g[1][0]
                    },
                    
                    3 => {
                        // 3D element: G is 3x3, standard 3x3 determinant  
                        g[0][0] * (g[1][1] * g[2][2] - g[1][2] * g[2][1])
                        - g[0][1] * (g[1][0] * g[2][2] - g[1][2] * g[2][0])
                        + g[0][2] * (g[1][0] * g[2][1] - g[1][1] * g[2][0])
                    }
                    
                    _ => return Err(ParseError::FormatError(format!(
                        "Determinant calculation not implemented for {}x{} G matrices", natural, natural
                    ))),
                };
                
                // Step 3: Handle sign for element inversion detection
                // Since G = J^T * J is always positive semi-definite, det(G) ≥ 0
                // We need to determine the sign from the orientation of the element
                let sign = calculate_element_orientation_sign(matrix, spatial, natural)?;
                
                // Step 4: Return signed sqrt(det(G)) as the Jacobian magnitude
                if det_g < 0.0 {
                    // This mathematically shouldn't happen for G = J^T*J, but handle gracefully
                    Ok(0.0)
                } else {
                    Ok(sign * det_g.sqrt())
                }
            }
            
            // Case 3: Unsupported square matrix sizes
            _ => {
                Err(ParseError::FormatError(format!(
                    "Determinant calculation not implemented for {}x{} matrices", spatial_dim, natural_dim
                )))
            }
        }
    }
}

/// Calculate the orientation sign for non-square Jacobian matrices
/// This determines if the element is inverted (negative orientation)
fn calculate_element_orientation_sign(
    matrix: &[Vec<f64>], 
    spatial_dim: usize, 
    natural_dim: usize
) -> Result<f64, ParseError> {
    match (spatial_dim, natural_dim) {
        // Case: 1D element in 2D or 3D mesh
        (2, 1) | (3, 1) => {
            // For 1D elements (lines), orientation is determined by the direction vector
            // J = [dx/dxi, dy/dxi] or [dx/dxi, dy/dxi, dz/dxi]
            // Sign is positive if element follows expected parametric direction
            // For simplicity, we can use the sign of the first non-zero component
            for i in 0..spatial_dim {
                if matrix[i][0].abs() > 1e-12 {  // Found first significant component
                    return Ok(if matrix[i][0] > 0.0 { 1.0 } else { -1.0 });
                }
            }
            // All components are zero - degenerate element
            Ok(1.0)  // Default to positive
        },
            
        // Case: 2D element in 3D mesh  
        (3, 2) => {
            // For 2D elements in 3D (surfaces), orientation is determined by cross product
            // J = [dx/dxi dx/deta; dy/dxi dy/deta; dz/dxi dz/deta]
            // Cross product: (dx/dxi, dy/dxi, dz/dxi) × (dx/deta, dy/deta, dz/deta)
            let u = [matrix[0][0], matrix[1][0], matrix[2][0]];  // First column: ∂r/∂xi
            let v = [matrix[0][1], matrix[1][1], matrix[2][1]];  // Second column: ∂r/∂eta
                
            // Cross product w = u × v
            let cross_product = [
                u[1] * v[2] - u[2] * v[1],  // i component
                u[2] * v[0] - u[0] * v[2],  // j component  
                u[0] * v[1] - u[1] * v[0],  // k component
            ];
                
            // The sign is determined by the z-component of the normal vector
            // (assuming standard right-hand rule orientation)
            // For more robust orientation, we could use the largest component
            let max_component = cross_product.iter()
                .max_by(|a, b| a.abs().partial_cmp(&b.abs()).unwrap_or(std::cmp::Ordering::Equal))
                .unwrap_or(&0.0);
                
            Ok(if *max_component >= 0.0 { 1.0 } else { -1.0 })
        },
            
        // Other cases not yet implemented
        _ => {
            // Default to positive orientation for unhandled cases
            Ok(1.0)
        }
    }
}

// Linear line element (2 nodes)
fn get_line_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 1 {
        return Err(ParseError::FormatError("Line elements require 1 natural coordinate".to_string()));
    }
    
    let xi = xi[0];
    
    let values = vec![
        0.5 * (1.0 - xi), // N0: node at xi = -1
        0.5 * (1.0 + xi), // N1: node at xi = +1
    ];
    let derivatives = vec![
        vec![-0.5], // dN0/dxi
        vec![0.5],  // dN1/dxi
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Quadratic line element (3 nodes)
fn get_quadratic_edge_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 1 {
        return Err(ParseError::FormatError("QuadraticEdge elements require 1 natural coordinate".to_string()));
    }
    
    let xi = xi[0];
    
    let values = vec![
        -0.5 * xi * (1.0 - xi),    // N0: node at xi = -1
        -0.5 * xi * (1.0 + xi),    // N1: node at xi = +1
        (1.0 - xi) * (1.0 + xi),   // N2: node at xi = 0
    ];
    let derivatives = vec![
        vec![-0.5 * (1.0 - 2.0 * xi)], // dN0/dxi
        vec![-0.5 * (1.0 + 2.0 * xi)], // dN1/dxi
        vec![-2.0 * xi],               // dN2/dxi
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Linear triangle (3 nodes)
fn get_triangle_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 2 {
        return Err(ParseError::FormatError("Triangle elements require 2 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    
    let values = vec![
        xi,               // N0: node at (1,0)
        eta,              // N1: node at (0,1)  
        1.0 - xi - eta,   // N2: node at (0,0)
    ];
    let derivatives = vec![
        vec![1.0, 0.0],   // dN0/dxi, dN0/deta
        vec![0.0, 1.0],   // dN1/dxi, dN1/deta
        vec![-1.0, -1.0], // dN2/dxi, dN2/deta
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Quadratic triangle (6 nodes)
fn get_quadratic_triangle_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 2 {
        return Err(ParseError::FormatError("QuadraticTriangle elements require 2 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let lambda = 1.0 - xi - eta;
    
    let values = vec![
        xi * (2.0 * xi - 1.0),           // N0: corner at (1,0)
        eta * (2.0 * eta - 1.0),         // N1: corner at (0,1)
        lambda * (2.0 * lambda - 1.0),   // N2: corner at (0,0)
        4.0 * xi * eta,                  // N3: mid-edge at (0.5,0.5)
        4.0 * eta * lambda,              // N4: mid-edge at (0,0.5)
        4.0 * xi * lambda,               // N5: mid-edge at (0.5,0)
    ];
    let derivatives = vec![
        vec![4.0 * xi - 1.0, 0.0],                                      // dN0
        vec![0.0, 4.0 * eta - 1.0],                                     // dN1
        vec![4.0 * (xi + eta) - 3.0, 4.0 * (xi + eta) - 3.0],          // dN2
        vec![4.0 * eta, 4.0 * xi],                                      // dN3
        vec![-4.0 * eta, 4.0 * (1.0 - xi - 2.0 * eta)],                // dN4
        vec![4.0 * (1.0 - 2.0 * xi - eta), -4.0 * xi],                 // dN5
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Bilinear quad (4 nodes)
fn get_quad_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 2 {
        return Err(ParseError::FormatError("Quad elements require 2 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    
    let values = vec![
        0.25 * (1.0 - xi) * (1.0 - eta), // N0: bottom-left (-1,-1)
        0.25 * (1.0 + xi) * (1.0 - eta), // N1: bottom-right (1,-1)
        0.25 * (1.0 + xi) * (1.0 + eta), // N2: top-right (1,1)
        0.25 * (1.0 - xi) * (1.0 + eta), // N3: top-left (-1,1)
    ];
    let derivatives = vec![
        vec![-0.25 * (1.0 - eta), -0.25 * (1.0 - xi)], // dN0
        vec![0.25 * (1.0 - eta), -0.25 * (1.0 + xi)],  // dN1
        vec![0.25 * (1.0 + eta), 0.25 * (1.0 + xi)],   // dN2
        vec![-0.25 * (1.0 + eta), 0.25 * (1.0 - xi)],  // dN3
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Quadratic quad - serendipity (8 nodes)
fn get_quadratic_quad_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 2 {
        return Err(ParseError::FormatError("QuadraticQuad elements require 2 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    
    let values = vec![
        -0.25 * (1.0 - xi) * (1.0 - eta) * (1.0 + xi + eta),         // N0: corner (-1,-1)
        -0.25 * (1.0 + xi) * (1.0 - eta) * (1.0 - xi + eta),         // N1: corner (1,-1)
        -0.25 * (1.0 + xi) * (1.0 + eta) * (1.0 - xi - eta),         // N2: corner (1,1)
        -0.25 * (1.0 - xi) * (1.0 + eta) * (1.0 + xi - eta),         // N3: corner (-1,1)
        0.5 * (1.0 - xi) * (1.0 + xi) * (1.0 - eta),                 // N4: mid-edge bottom (0,-1)
        0.5 * (1.0 - eta) * (1.0 + eta) * (1.0 + xi),                // N5: mid-edge right (1,0)
        0.5 * (1.0 - xi) * (1.0 + xi) * (1.0 + eta),                 // N6: mid-edge top (0,1)
        0.5 * (1.0 - eta) * (1.0 + eta) * (1.0 - xi),                // N7: mid-edge left (-1,0)
    ];
    
    let derivatives = vec![
        
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Biquadratic quad (9 nodes)  //not done
fn get_biquadratic_quad_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 2 {
        return Err(ParseError::FormatError("BiquadraticQuad elements require 2 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    
    let values = vec![
        0.25 * xi * (xi - 1.0) * eta * (eta - 1.0),   // N0: corner (-1,-1)
        0.25 * xi * (xi + 1.0) * eta * (eta - 1.0),   // N1: corner (1,-1)
        0.25 * xi * (xi + 1.0) * eta * (eta + 1.0),   // N2: corner (1,1)
        0.25 * xi * (xi - 1.0) * eta * (eta + 1.0),   // N3: corner (-1,1)
        -0.5 * (xi * xi - 1.0) * eta * (eta - 1.0),   // N4: mid-edge bottom (0,-1)
        -0.5 * xi * (xi + 1.0) * (eta * eta - 1.0),   // N5: mid-edge right (1,0)
        -0.5 * (xi * xi - 1.0) * eta * (eta + 1.0),   // N6: mid-edge top (0,1)
        -0.5 * xi * (xi - 1.0) * (eta * eta - 1.0),   // N7: mid-edge left (-1,0)
        (xi * xi - 1.0) * (eta * eta - 1.0),          // N8: center (0,0)
    ];
    
    let derivatives = vec![
        vec![0.25 * (2.0 * xi - 1.0) * eta * (eta - 1.0), 0.25 * xi * (xi - 1.0) * (2.0 * eta - 1.0)], // dN0
        vec![0.25 * (2.0 * xi + 1.0) * eta * (eta - 1.0), 0.25 * xi * (xi + 1.0) * (2.0 * eta - 1.0)], // dN1
        vec![0.25 * (2.0 * xi + 1.0) * eta * (eta + 1.0), 0.25 * xi * (xi + 1.0) * (2.0 * eta + 1.0)], // dN2
        vec![0.25 * (2.0 * xi - 1.0) * eta * (eta + 1.0), 0.25 * xi * (xi - 1.0) * (2.0 * eta + 1.0)], // dN3
        vec![-xi * eta * (eta - 1.0), -0.5 * (xi * xi - 1.0) * (2.0 * eta - 1.0)], // dN4
        vec![-0.5 * (2.0 * xi + 1.0) * (eta * eta - 1.0), -xi * (xi + 1.0) * eta], // dN5
        vec![-xi * eta * (eta + 1.0), -0.5 * (xi * xi - 1.0) * (2.0 * eta + 1.0)], // dN6
        vec![-0.5 * (2.0 * xi - 1.0) * (eta * eta - 1.0), -xi * (xi - 1.0) * eta], // dN7
        vec![-2.0 * xi * (eta * eta - 1.0), -2.0 * eta * (xi * xi - 1.0)], // dN8
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Linear tetrahedron (4 nodes)
fn get_tetra_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("Tetra elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    
    let values = vec![
        xi,                     // N0: node at (1,0,0)
        eta,                    // N1: node at (0,1,0)
        zeta,                   // N2: node at (0,0,1)
        1.0 - xi - eta - zeta,  // N3: node at (0,0,0)
    ];
    let derivatives = vec![
        vec![1.0, 0.0, 0.0],    // dN0
        vec![0.0, 1.0, 0.0],    // dN1
        vec![0.0, 0.0, 1.0],    // dN2
        vec![-1.0, -1.0, -1.0], // dN3
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Quadratic tetrahedron (10 nodes)
fn get_quadratic_tetra_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("QuadraticTetra elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    let lambda = 1.0 - xi - eta - zeta;
    
    let values = vec![
        xi * (2.0 * xi - 1.0),           // N0: corner (1,0,0)
        eta * (2.0 * eta - 1.0),         // N1: corner (0,1,0)
        zeta * (2.0 * zeta - 1.0),       // N2: corner (0,0,1)
        lambda * (2.0 * lambda - 1.0),   // N3: corner (0,0,0)
        4.0 * xi * eta,                  // N4: mid-edge (0.5,0.5,0)
        4.0 * eta * zeta,                // N5: mid-edge (0,0.5,0.5)
        4.0 * xi * zeta,                 // N6: mid-edge (0.5,0,0.5)
        4.0 * xi * lambda,               // N7: mid-edge (0.5,0,0)
        4.0 * eta * lambda,              // N8: mid-edge (0,0.5,0)
        4.0 * zeta * lambda,             // N9: mid-edge (0,0,0.5)
    ];
    
    let derivatives = vec![
        vec![4.0 * xi - 1.0, 0.0, 0.0],                                              // dN0
        vec![0.0, 4.0 * eta - 1.0, 0.0],                                             // dN1
        vec![0.0, 0.0, 4.0 * zeta - 1.0],                                            // dN2
        vec![4.0 * (xi + eta + zeta) - 3.0, 4.0 * (xi + eta + zeta) - 3.0, 4.0 * (xi + eta + zeta) - 3.0], // dN3
        vec![4.0 * eta, 4.0 * xi, 0.0],                                              // dN4
        vec![0.0, 4.0 * zeta, 4.0 * eta],                                            // dN5
        vec![4.0 * zeta, 0.0, 4.0 * xi],                                             // dN6
        vec![4.0 * (1.0 - 2.0 * xi - eta - zeta), -4.0 * xi, -4.0 * xi],           // dN7
        vec![-4.0 * eta, 4.0 * (1.0 - xi - 2.0 * eta - zeta), -4.0 * eta],         // dN8
        vec![-4.0 * zeta, -4.0 * zeta, 4.0 * (1.0 - xi - eta - 2.0 * zeta)],       // dN9
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Linear pyramid (5 nodes)
fn get_pyramid_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("Pyramid elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    
    let values = vec![
        0.25 * (1.0 - xi) * (1.0 - zeta) * (1.0 - eta), // N0: base (-1,-1,-1)
        0.25 * (1.0 - xi) * (1.0 + zeta) * (1.0 - eta), // N1: base (-1,-1,1)
        0.25 * (1.0 + xi) * (1.0 + zeta) * (1.0 - eta), // N2: base (1,-1,1)
        0.25 * (1.0 + xi) * (1.0 - zeta) * (1.0 - eta), // N3: base (1,-1,-1)
        0.5 * (1.0 + eta),                               // N4: apex (0,1,0)
    ];
    
    let derivatives = vec![
        vec![-0.25 * (1.0 - zeta) * (1.0 - eta), -0.25 * (1.0 - xi) * (1.0 - zeta), -0.25 * (1.0 - xi) * (1.0 - eta)], // dN0
        vec![-0.25 * (1.0 + zeta) * (1.0 - eta), -0.25 * (1.0 - xi) * (1.0 + zeta), 0.25 * (1.0 - xi) * (1.0 - eta)],  // dN1
        vec![0.25 * (1.0 + zeta) * (1.0 - eta), -0.25 * (1.0 + xi) * (1.0 + zeta), 0.25 * (1.0 + xi) * (1.0 - eta)],   // dN2
        vec![0.25 * (1.0 - zeta) * (1.0 - eta), -0.25 * (1.0 + xi) * (1.0 - zeta), -0.25 * (1.0 + xi) * (1.0 - eta)],  // dN3
        vec![0.0, 0.5, 0.0], // dN4
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Quadratic pyramid (13 nodes) - placeholder for now
fn get_quadratic_pyramid_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    Err(ParseError::FormatError("QuadraticPyramid shape functions not yet implemented".to_string()))
}

// Linear wedge (6 nodes)
fn get_wedge_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("Wedge elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    let lambda = 1.0 - xi - zeta; // Third coordinate for triangular cross-section
    
    let values = vec![
        0.5 * lambda * (1.0 - eta), // N0: bottom (0,-1,0)
        0.5 * zeta * (1.0 - eta),   // N1: bottom (0,-1,1)
        0.5 * xi * (1.0 - eta),     // N2: bottom (1,-1,0)
        0.5 * lambda * (1.0 + eta), // N3: top (0,1,0)
        0.5 * zeta * (1.0 + eta),   // N4: top (0,1,1)
        0.5 * xi * (1.0 + eta),     // N5: top (1,1,0)
    ];
    
    let derivatives = vec![
        vec![-0.5 * (1.0 - eta), -0.5 * lambda, -0.5 * (1.0 - eta)], // dN0
        vec![0.0, -0.5 * zeta, 0.5 * (1.0 - eta)],                    // dN1
        vec![0.5 * (1.0 - eta), -0.5 * xi, 0.0],                      // dN2
        vec![-0.5 * (1.0 + eta), 0.5 * lambda, -0.5 * (1.0 + eta)],  // dN3
        vec![0.0, 0.5 * zeta, 0.5 * (1.0 + eta)],                     // dN4
        vec![0.5 * (1.0 + eta), 0.5 * xi, 0.0],                       // dN5
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Quadratic wedge (15 nodes)
fn get_quadratic_wedge_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("QuadraticWedge elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    let lambda = 1.0 - xi - zeta;
    
    let values = vec![
        // Corner nodes
        0.5 * lambda * (2.0 * lambda - 1.0) * (1.0 - eta), // N0: bottom corner (0,-1,0)
        0.5 * zeta * (2.0 * zeta - 1.0) * (1.0 - eta),     // N1: bottom corner (0,-1,1)
        0.5 * xi * (2.0 * xi - 1.0) * (1.0 - eta),         // N2: bottom corner (1,-1,0)
        0.5 * lambda * (2.0 * lambda - 1.0) * (1.0 + eta), // N3: top corner (0,1,0)
        0.5 * zeta * (2.0 * zeta - 1.0) * (1.0 + eta),     // N4: top corner (0,1,1)
        0.5 * xi * (2.0 * xi - 1.0) * (1.0 + eta),         // N5: top corner (1,1,0)
        // Mid-edge nodes on faces
        2.0 * lambda * zeta * (1.0 - eta),                 // N6: bottom face (0,-1,0.5)
        2.0 * xi * zeta * (1.0 - eta),                     // N7: bottom face (0.5,-1,0.5)
        2.0 * xi * lambda * (1.0 - eta),                   // N8: bottom face (0.5,-1,0)
        2.0 * lambda * zeta * (1.0 + eta),                 // N9: top face (0,1,0.5)
        2.0 * xi * zeta * (1.0 + eta),                     // N10: top face (0.5,1,0.5)
        2.0 * xi * lambda * (1.0 + eta),                   // N11: top face (0.5,1,0)
        // Vertical mid-edge nodes
        lambda * (1.0 - eta * eta),                        // N12: vertical (0,0,0)
        zeta * (1.0 - eta * eta),                           // N13: vertical (0,0,1)
        xi * (1.0 - eta * eta),                             // N14: vertical (1,0,0)
    ];
    
    let derivatives = vec![
        vec![-0.5 * (4.0 * lambda - 1.0) * (1.0 - eta), -0.5 * lambda * (2.0 * lambda - 1.0), -0.5 * (4.0 * lambda - 1.0) * (1.0 - eta)], // dN0
        vec![0.0, -0.5 * zeta * (2.0 * zeta - 1.0), 0.5 * (4.0 * zeta - 1.0) * (1.0 - eta)], // dN1
        vec![0.5 * (4.0 * xi - 1.0) * (1.0 - eta), -0.5 * xi * (2.0 * xi - 1.0), 0.0], // dN2
        vec![-0.5 * (4.0 * lambda - 1.0) * (1.0 + eta), 0.5 * lambda * (2.0 * lambda - 1.0), -0.5 * (4.0 * lambda - 1.0) * (1.0 + eta)], // dN3
        vec![0.0, 0.5 * zeta * (2.0 * zeta - 1.0), 0.5 * (4.0 * zeta - 1.0) * (1.0 + eta)], // dN4
        vec![0.5 * (4.0 * xi - 1.0) * (1.0 + eta), 0.5 * xi * (2.0 * xi - 1.0), 0.0], // dN5
        // Mid-edge derivatives
        vec![-2.0 * zeta * (1.0 - eta), -2.0 * lambda * zeta, 2.0 * lambda * (1.0 - eta)], // dN6
        vec![2.0 * zeta * (1.0 - eta), -2.0 * xi * zeta, 2.0 * xi * (1.0 - eta)], // dN7
        vec![2.0 * lambda * (1.0 - eta), -2.0 * xi * lambda, -2.0 * xi * (1.0 - eta)], // dN8
        vec![-2.0 * zeta * (1.0 + eta), 2.0 * lambda * zeta, 2.0 * lambda * (1.0 + eta)], // dN9
        vec![2.0 * zeta * (1.0 + eta), 2.0 * xi * zeta, 2.0 * xi * (1.0 + eta)], // dN10
        vec![2.0 * lambda * (1.0 + eta), 2.0 * xi * lambda, -2.0 * xi * (1.0 + eta)], // dN11
        // Vertical mid-edge derivatives
        vec![-(1.0 - eta * eta), -2.0 * lambda * eta, -(1.0 - eta * eta)], // dN12
        vec![0.0, -2.0 * zeta * eta, (1.0 - eta * eta)], // dN13
        vec![(1.0 - eta * eta), -2.0 * xi * eta, 0.0], // dN14
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Biquadratic-quadratic wedge (18 nodes)
fn get_biquadratic_quadratic_wedge_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("BiquadraticQuadraticWedge elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    let lambda = 1.0 - xi - zeta;
    
    let values = vec![
        // Corner nodes (0-5)
        0.5 * lambda * (2.0 * lambda - 1.0) * (1.0 - eta), // N0: bottom corner (0,-1,0)
        0.5 * zeta * (2.0 * zeta - 1.0) * (1.0 - eta),     // N1: bottom corner (0,-1,1)
        0.5 * xi * (2.0 * xi - 1.0) * (1.0 - eta),         // N2: bottom corner (1,-1,0)
        0.5 * lambda * (2.0 * lambda - 1.0) * (1.0 + eta), // N3: top corner (0,1,0)
        0.5 * zeta * (2.0 * zeta - 1.0) * (1.0 + eta),     // N4: top corner (0,1,1)
        0.5 * xi * (2.0 * xi - 1.0) * (1.0 + eta),         // N5: top corner (1,1,0)
        // Bottom face mid-edge nodes (6-8)
        2.0 * lambda * zeta * (1.0 - eta),                 // N6: bottom face (0,-1,0.5)
        2.0 * xi * zeta * (1.0 - eta),                     // N7: bottom face (0.5,-1,0.5)
        2.0 * xi * lambda * (1.0 - eta),                   // N8: bottom face (0.5,-1,0)
        // Top face mid-edge nodes (9-11)
        2.0 * lambda * zeta * (1.0 + eta),                 // N9: top face (0,1,0.5)
        2.0 * xi * zeta * (1.0 + eta),                     // N10: top face (0.5,1,0.5)
        2.0 * xi * lambda * (1.0 + eta),                   // N11: top face (0.5,1,0)
        // Vertical mid-edge nodes (12-14)
        lambda * (1.0 - eta * eta),                        // N12: vertical (0,0,0)
        zeta * (1.0 - eta * eta),                           // N13: vertical (0,0,1)
        xi * (1.0 - eta * eta),                             // N14: vertical (1,0,0)
        // Mid-face nodes (15-17)
        2.0 * lambda * zeta * eta,                          // N15: mid-face (0,0,0.5)
        2.0 * xi * zeta * eta,                              // N16: mid-face (0.5,0,0.5)
        2.0 * xi * lambda * eta,                            // N17: mid-face (0.5,0,0)
    ];
    
    let derivatives = vec![
        // Corner derivatives
        vec![-0.5 * (4.0 * lambda - 1.0) * (1.0 - eta), -0.5 * lambda * (2.0 * lambda - 1.0), -0.5 * (4.0 * lambda - 1.0) * (1.0 - eta)], // dN0
        vec![0.0, -0.5 * zeta * (2.0 * zeta - 1.0), 0.5 * (4.0 * zeta - 1.0) * (1.0 - eta)], // dN1
        vec![0.5 * (4.0 * xi - 1.0) * (1.0 - eta), -0.5 * xi * (2.0 * xi - 1.0), 0.0], // dN2
        vec![-0.5 * (4.0 * lambda - 1.0) * (1.0 + eta), 0.5 * lambda * (2.0 * lambda - 1.0), -0.5 * (4.0 * lambda - 1.0) * (1.0 + eta)], // dN3
        vec![0.0, 0.5 * zeta * (2.0 * zeta - 1.0), 0.5 * (4.0 * zeta - 1.0) * (1.0 + eta)], // dN4
        vec![0.5 * (4.0 * xi - 1.0) * (1.0 + eta), 0.5 * xi * (2.0 * xi - 1.0), 0.0], // dN5
        // Face mid-edge derivatives
        vec![-2.0 * zeta * (1.0 - eta), -2.0 * lambda * zeta, 2.0 * lambda * (1.0 - eta)], // dN6
        vec![2.0 * zeta * (1.0 - eta), -2.0 * xi * zeta, 2.0 * xi * (1.0 - eta)], // dN7
        vec![2.0 * lambda * (1.0 - eta), -2.0 * xi * lambda, -2.0 * xi * (1.0 - eta)], // dN8
        vec![-2.0 * zeta * (1.0 + eta), 2.0 * lambda * zeta, 2.0 * lambda * (1.0 + eta)], // dN9
        vec![2.0 * zeta * (1.0 + eta), 2.0 * xi * zeta, 2.0 * xi * (1.0 + eta)], // dN10
        vec![2.0 * lambda * (1.0 + eta), 2.0 * xi * lambda, -2.0 * xi * (1.0 + eta)], // dN11
        // Vertical mid-edge derivatives
        vec![-(1.0 - eta * eta), -2.0 * lambda * eta, -(1.0 - eta * eta)], // dN12
        vec![0.0, -2.0 * zeta * eta, (1.0 - eta * eta)], // dN13
        vec![(1.0 - eta * eta), -2.0 * xi * eta, 0.0], // dN14
        // Mid-face derivatives
        vec![-2.0 * zeta * eta, 2.0 * lambda * zeta, 2.0 * lambda * eta], // dN15
        vec![2.0 * zeta * eta, 2.0 * xi * zeta, 2.0 * xi * eta], // dN16
        vec![2.0 * lambda * eta, 2.0 * xi * lambda, -2.0 * xi * eta], // dN17
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Linear hexahedron (8 nodes)
fn get_hexahedron_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("Hexahedron elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    
    let values = vec![
        0.125 * (1.0 - xi) * (1.0 - eta) * (1.0 - zeta), // N0: (-1,-1,-1)
        0.125 * (1.0 - xi) * (1.0 - eta) * (1.0 + zeta), // N1: (-1,-1,1)
        0.125 * (1.0 + xi) * (1.0 - eta) * (1.0 + zeta), // N2: (1,-1,1)
        0.125 * (1.0 + xi) * (1.0 - eta) * (1.0 - zeta), // N3: (1,-1,-1)
        0.125 * (1.0 - xi) * (1.0 + eta) * (1.0 - zeta), // N4: (-1,1,-1)
        0.125 * (1.0 - xi) * (1.0 + eta) * (1.0 + zeta), // N5: (-1,1,1)
        0.125 * (1.0 + xi) * (1.0 + eta) * (1.0 + zeta), // N6: (1,1,1)
        0.125 * (1.0 + xi) * (1.0 + eta) * (1.0 - zeta), // N7: (1,1,-1)
    ];
    
    let derivatives = vec![
        vec![-0.125 * (1.0 - eta) * (1.0 - zeta), -0.125 * (1.0 - xi) * (1.0 - zeta), -0.125 * (1.0 - xi) * (1.0 - eta)], // dN0
        vec![-0.125 * (1.0 - eta) * (1.0 + zeta), -0.125 * (1.0 - xi) * (1.0 + zeta), 0.125 * (1.0 - xi) * (1.0 - eta)], // dN1
        vec![0.125 * (1.0 - eta) * (1.0 + zeta), -0.125 * (1.0 + xi) * (1.0 + zeta), 0.125 * (1.0 + xi) * (1.0 - eta)], // dN2
        vec![0.125 * (1.0 - eta) * (1.0 - zeta), -0.125 * (1.0 + xi) * (1.0 - zeta), -0.125 * (1.0 + xi) * (1.0 - eta)], // dN3
        vec![-0.125 * (1.0 + eta) * (1.0 - zeta), 0.125 * (1.0 - xi) * (1.0 - zeta), -0.125 * (1.0 - xi) * (1.0 + eta)], // dN4
        vec![-0.125 * (1.0 + eta) * (1.0 + zeta), 0.125 * (1.0 - xi) * (1.0 + zeta), 0.125 * (1.0 - xi) * (1.0 + eta)], // dN5
        vec![0.125 * (1.0 + eta) * (1.0 + zeta), 0.125 * (1.0 + xi) * (1.0 + zeta), 0.125 * (1.0 + xi) * (1.0 + eta)], // dN6
        vec![0.125 * (1.0 + eta) * (1.0 - zeta), 0.125 * (1.0 + xi) * (1.0 - zeta), -0.125 * (1.0 + xi) * (1.0 + eta)], // dN7
    ];
    Ok(ShapeFunction { values, derivatives })
}

// Quadratic hexahedron - serendipity (20 nodes)
fn get_quadratic_hexahedron_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("QuadraticHexahedron elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    
    let mut values = vec![0.0; 20];
    let mut derivatives = vec![vec![0.0; 3]; 20];
    
    // Corner nodes (0-7) - serendipity formulation
    values[0] = 0.125 * (1.0 - xi) * (1.0 - eta) * (1.0 - zeta) * (-xi - eta - zeta - 2.0);
    values[1] = 0.125 * (1.0 - xi) * (1.0 - eta) * (1.0 + zeta) * (-xi - eta + zeta - 2.0);
    values[2] = 0.125 * (1.0 + xi) * (1.0 - eta) * (1.0 + zeta) * (xi - eta + zeta - 2.0);
    values[3] = 0.125 * (1.0 + xi) * (1.0 - eta) * (1.0 - zeta) * (xi - eta - zeta - 2.0);
    values[4] = 0.125 * (1.0 - xi) * (1.0 + eta) * (1.0 - zeta) * (-xi + eta - zeta - 2.0);
    values[5] = 0.125 * (1.0 - xi) * (1.0 + eta) * (1.0 + zeta) * (-xi + eta + zeta - 2.0);
    values[6] = 0.125 * (1.0 + xi) * (1.0 + eta) * (1.0 + zeta) * (xi + eta + zeta - 2.0);
    values[7] = 0.125 * (1.0 + xi) * (1.0 + eta) * (1.0 - zeta) * (xi + eta - zeta - 2.0);
    
    // Mid-edge nodes (8-19)
    values[8] = 0.25 * (1.0 - xi * xi) * (1.0 - eta) * (1.0 - zeta);    // bottom back edge
    values[9] = 0.25 * (1.0 + xi) * (1.0 - eta * eta) * (1.0 + zeta);   // right front edge  
    values[10] = 0.25 * (1.0 - xi * xi) * (1.0 - eta) * (1.0 + zeta);   // bottom front edge
    values[11] = 0.25 * (1.0 - xi) * (1.0 - eta * eta) * (1.0 - zeta);  // left back edge
    values[12] = 0.25 * (1.0 - xi * xi) * (1.0 + eta) * (1.0 - zeta);   // top back edge
    values[13] = 0.25 * (1.0 + xi) * (1.0 - eta * eta) * (1.0 + zeta);  // right front edge
    values[14] = 0.25 * (1.0 - xi * xi) * (1.0 + eta) * (1.0 + zeta);   // top front edge
    values[15] = 0.25 * (1.0 - xi) * (1.0 - eta * eta) * (1.0 + zeta);  // left front edge
    values[16] = 0.25 * (1.0 - xi) * (1.0 - eta) * (1.0 - zeta * zeta); // bottom left vertical
    values[17] = 0.25 * (1.0 + xi) * (1.0 - eta) * (1.0 - zeta * zeta); // bottom right vertical
    values[18] = 0.25 * (1.0 + xi) * (1.0 + eta) * (1.0 - zeta * zeta); // top right vertical
    values[19] = 0.25 * (1.0 - xi) * (1.0 + eta) * (1.0 - zeta * zeta); // top left vertical
    
    // Derivatives for serendipity elements (complex - simplified here)
    for i in 0..20 {
        derivatives[i] = vec![0.0, 0.0, 0.0]; // Would need full calculation for each node
    }
    
    Ok(ShapeFunction { values, derivatives })
}

// Biquadratic-quadratic hexahedron (24 nodes)
fn get_biquadratic_quadratic_hexahedron_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("BiquadraticQuadraticHexahedron elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    
    let mut values = vec![0.0; 24];
    let mut derivatives = vec![vec![0.0; 3]; 24];
    
    // Corner nodes (0-7)
    for i in 0..8 {
        let xi_val = if i & 1 == 0 { -1.0 } else { 1.0 };
        let eta_val = if i < 4 { -1.0 } else { 1.0 };
        let zeta_val = if (i == 0 || i == 3 || i == 4 || i == 7) { -1.0 } else { 1.0 };
        
        values[i] = 0.125 * (1.0 + xi_val * xi) * (1.0 + eta_val * eta) * (1.0 + zeta_val * zeta);
        derivatives[i] = vec![
            0.125 * xi_val * (1.0 + eta_val * eta) * (1.0 + zeta_val * zeta),
            0.125 * (1.0 + xi_val * xi) * eta_val * (1.0 + zeta_val * zeta),
            0.125 * (1.0 + xi_val * xi) * (1.0 + eta_val * eta) * zeta_val,
        ];
    }
    
    // Mid-edge and face nodes (8-23) would be calculated similarly
    // Placeholder for brevity
    for i in 8..24 {
        values[i] = 0.0;
        derivatives[i] = vec![0.0, 0.0, 0.0];
    }
    
    Ok(ShapeFunction { values, derivatives })
}

// Triquadratic hexahedron (27 nodes)
fn get_triquadratic_hexahedron_shape_functions(xi: &[f64]) -> Result<ShapeFunction, ParseError> {
    if xi.len() != 3 {
        return Err(ParseError::FormatError("TriquadraticHexahedron elements require 3 natural coordinates".to_string()));
    }
    
    let xi = xi[0];
    let eta = xi[1];
    let zeta = xi[2];
    
    // Define 1D Lagrange quadratic shape functions
    let lagrange_1d = |coord: f64| -> [f64; 3] {
        [
            0.5 * coord * (coord - 1.0),   // function for -1
            0.5 * coord * (coord + 1.0),   // function for +1
            1.0 - coord * coord,           // function for 0
        ]
    };
    
    let lagrange_1d_deriv = |coord: f64| -> [f64; 3] {
        [
            coord - 0.5,      // derivative for -1
            coord + 0.5,      // derivative for +1
            -2.0 * coord,     // derivative for 0
        ]
    };
    
    let n_xi = lagrange_1d(xi);
    let n_eta = lagrange_1d(eta);
    let n_zeta = lagrange_1d(zeta);
    
    let dn_xi = lagrange_1d_deriv(xi);
    let dn_eta = lagrange_1d_deriv(eta);
    let dn_zeta = lagrange_1d_deriv(zeta);
    
    let mut values = vec![0.0; 27];
    let mut derivatives = vec![vec![0.0; 3]; 27];
    
    // Tensor product construction for all 27 nodes
    let mut node_idx = 0;
    for k in 0..3 { // zeta direction (-1, +1, 0)
        for j in 0..3 { // eta direction (-1, +1, 0)
            for i in 0..3 { // xi direction (-1, +1, 0)
                values[node_idx] = n_xi[i] * n_eta[j] * n_zeta[k];
                derivatives[node_idx] = vec![
                    dn_xi[i] * n_eta[j] * n_zeta[k],  // dN/dxi
                    n_xi[i] * dn_eta[j] * n_zeta[k],  // dN/deta
                    n_xi[i] * n_eta[j] * dn_zeta[k],  // dN/dzeta
                ];
                node_idx += 1;
            }
        }
    }
    
    Ok(ShapeFunction { values, derivatives })
}
